gerarchia di tipi:

CalcolabileAstratto<T>

contiene metodi astratti indipendenti dal tipo di calcolabile

contiene metodi:

Operazioni Ulteriori

-> distruttore (virtuale) -> rende distruttori in gerarchia virtuale
-> isEmpty(virtuale,puro,parametrico,statico) -> true sse elemento
   passato e' nullo
-> addConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di somma, false altrimenti
-> subConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di sottrazione,false altrimenti
-> mulConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di prodotto,false altrimenti
-> divConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di divisione,false altrimenti



VettoreAstratto<T>

Vettore sottotipo di Calcolabile

contiene metodi astratti di calcolo propri di ogni Vettore 

contiene metodi:

Operazioni Algebriche

-> operator+ (virtuale,puro,parametrico) -> somma tra 2 vettori
-> operator- (virtuale,puro,parametrico) -> differenza tra 2 vettori
-> operator* (virtuale,puro,parametrico) -> prodotto di 2 vettori 
-> operator* scalare (virtuale,puro,parametrico) -> prodotto di scalare per Vettore
-> operator/ scalare (virtuale,puro,parametrico) -> divisione di Vettore per scalare

Operazioni Booleane

-> operator== (virtuale,puro,parametrico) -> true sse
   2 vettori sono uguali , false altrimenti
-> operator!= (virtuale,puro,parametrico) -> true sse
   2 vettori sono diversi , false altrimenti
-> operator<  (virtuale,puro,parametrico) -> true sse
   primo vettore minore del secondo, false altrimenti
-> operator<= (virtuale,puro,parametrico) -> true sse
   primo vettore minore o uguale del secondo ,false altrimenti
-> operator> (virtuale,puro,parametrico) -> true sse
   primo vettore maggiore di secondo ,false altrimenti
-> operator>= (virtuale,puro,parametrico) -> true sse
   primo vettore maggiore o uguale di secondo,false altrimenti 


Operazioni Ulteriori

-> getRowNumber (virtuale) -> numero righe appartenenti al vettore  
-> isEmpty(virtuale,puro,parametrico,statico) -> true sse elemento
   passato e' nullo
-> addConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di somma, false altrimenti
-> subConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di sottrazione,false altrimenti
-> mulConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di prodotto,false altrimenti
-> divConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di divisione,false altrimenti


VettoreConcreto<T>

T = Razionale,Intero,Double 

implementazione concreta e templatizzata di metodi appartenenti a vettoreAstratto

implementazione metodo aggiuntivo reduceAll(T = Razionale) 
implementazione metodo aggiuntivo powerAll(T = intero) 
implementazione metodo aggiuntivo fractionalAll(T = double)

contieneMetodi:

Operazioni Algebriche


-> operator+ (virtuale,puro,parametrico) -> somma tra 2 vettori
-> operator- (virtuale,puro,parametrico) -> differenza tra 2 vettori
-> operator* (virtuale,puro,parametrico) -> prodotto di 2 vettori 
-> operator* scalare (virtuale,puro,parametrico) -> prodotto di scalare per Vettore
-> operator/ scalare (virtuale,puro,parametrico) -> divisione di Vettore per scalare

Operazioni Booleane

-> operator== (virtuale,puro,parametrico) -> true sse
   2 vettori sono uguali , false altrimenti
-> operator!= (virtuale,puro,parametrico) -> true sse
   2 vettori sono diversi , false altrimenti
-> operator<  (virtuale,puro,parametrico) -> true sse
   primo vettore minore del secondo, false altrimenti
-> operator<= (virtuale,puro,parametrico) -> true sse
   primo vettore minore o uguale del secondo ,false altrimenti
-> operator> (virtuale,puro,parametrico) -> true sse
   primo vettore maggiore di secondo ,false altrimenti
-> operator>= (virtuale,puro,parametrico) -> true sse
   primo vettore maggiore o uguale di secondo,false altrimenti 

   
Operazioni Ulteriori

-> getRowNumber (virtuale) -> ritorna numero righe appartenenti al vettore  

-> isEmpty(virtuale,puro,parametrico,statico) -> true sse elemento
   passato e' nullo
-> addConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di somma, false altrimenti
-> subConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di sottrazione,false altrimenti
-> mulConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di prodotto,false altrimenti
-> divConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di divisione,false altrimenti

Operazioni Proprie
-> (T = Razionale) reduceAll -> riduce ai minimi termini ogni elemento Vettore
-> (T = Intero) powerAll -> ritorna T tc T e' somma di Potenza di ogni elemento appartenente a vettore
-> (T = Double) fractionalAll -> ritorna T tc T e' somma di parteFrazionaria di ogni elemento di Vettore 

MatriceAstratta<T>

matrice sottotipo di Calcolabile

contiene metodi astratti di calcolo propri di ogni matrice

contiene metodi:

-> operator+ (virtuale,puro,parametrico) -> somma tra 2 vettori
-> operator- (virtuale,puro,parametrico) -> differenza tra 2 vettori
-> operator* (virtuale,puro,parametrico) -> prodotto di 2 vettori 
-> operator* scalare (virtuale,puro,parametrico) -> prodotto di scalare per Vettore
-> operator/ scalare (virtuale,puro,parametrico) -> divisione di Vettore per scalare

Operazioni Booleane

-> operator== (virtuale,puro,parametrico) -> true sse
   2 vettori sono uguali , false altrimenti
-> operator!= (virtuale,puro,parametrico) -> true sse
   2 vettori sono diversi , false altrimenti
-> operator<  (virtuale,puro,parametrico) -> true sse
   primo matrice minore del secondo, false altrimenti
-> operator<= (virtuale,puro,parametrico) -> true sse
   primo matrice minore o uguale del secondo ,false altrimenti
-> operator> (virtuale,puro,parametrico) -> true sse
   primo matrice maggiore di secondo ,false altrimenti
-> operator>= (virtuale,puro,parametrico) -> true sse
   primo matrice maggiore o uguale di secondo,false altrimenti 

Operazioni Ulteriori

-> transpose  (virtuale,puro) -> ritorna matrice trasposta rispetto alla matrice originale
-> getRowNumber (virtuale) -> ritorna il numero di righe che compongono matrice
-> getColumnNumber (virtuale)-> ritorna il numero di colonne che compongono matrice
-> getElementNumber(virtuale) -> ritorna il numero di elementi che compongono la matrice
-> isSquare -> ritorna true sse righe di matrice sono uguali a colonne, false altrimenti
-> isIdentity -> ritorna true sse matrice e' matrice identita', false altrimenti
-> isUpperTriangular -> ritorna true sse matrice e' matrice triangolare superiore , false altrimenti
-> isLowerTriangular -> ritorna true sse matrice e' matrice triangolare inferiore , false altrimenti

-> isEmpty(virtuale,puro,parametrico,statico) -> true sse elemento
   passato e' nullo
-> addConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di somma, false altrimenti
-> subConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di sottrazione,false altrimenti
-> mulConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di prodotto,false altrimenti
-> divConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di divisione,false altrimenti


MatriceConcreta<T>

T = Razionale,Intero,Double

implementazione concreta e templatizzata di metodi appartenenti a supertipo

implementazione metodo aggiuntivo reduceAll(T = Razionale) 
implementazione metodo aggiuntivo powerAll(T = intero) 
implementazione metodo aggiuntivo fractionalAll(T = double)

contiene metodi:

Operazioni Algebriche

-> operator+ (virtuale,puro,parametrico) -> somma tra 2 matrici
-> operator-(virtuale,puro,parametrico) -> differenza tra 2 matrici
-> operator* (virtuale,puro,parametrico) -> ritorna matrice risultato del prodotto tra le matrici passate
-> operator* scalare (virtuale,puro,parametrico) -> ritorna Matrice ottenuto da
   prodotto di scalare per Matrice
-> operator/(virtuale,puro,parametrico) -> ritorna Matrice ottenuto da
   divisione per scalare di Matrice

Operazioni Booleane

-> operator==(virtuale,puro,parametrico) -> ritorna true sse oggetti sono uguali per ogni elemento che li compone ,false altrimenti
-> operator!=(virtuale,puro,parametrico) -> negazione di uguaglianza

-> operator<  (virtuale,puro,parametrico) -> ritorna true sse primo matrice < secondo , false altrimenti
-> operator<= (virtuale,puro,parametrico) -> ritorna true sse primo matrice <= secondo , false altrimenti

-> operator> (virtuale,puro,parametrico) -> ritorna true sse primo matrice > secondo , false altrimenti
-> operator>= (virtuale,puro,parametrico) -> ritorna true sse primo matrice >= secondo , false altrimenti

Operazioni Ulteriori

-> transpone  (virtuale,puro) -> ritorna matrice trasposta rispetto alla matrice originale
-> getRowNumber (virtuale) -> ritorna il numero di righe che compongono matrice
-> getColumnNumber (virtuale)-> ritorna il numero di colonne che compongono matrice
-> getElementNumber(virtuale) -> ritorna il numero di elementi che compongono la matrice

-> isEmpty(virtuale,puro,parametrico,statico) -> true sse elemento
   passato e' nullo
-> addConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di somma, false altrimenti
-> subConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di sottrazione,false altrimenti
-> mulConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di prodotto,false altrimenti
-> divConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di divisione,false altrimenti

Operazioni Proprie

-> (T = Razionale) reduceAll -> riduce ai minimi termini ogni elementoVettore
-> (T = Intero) powerAll -> ritorna T tc T e' somma di Potenza di ogni elemento
   appartenente a vettore
-> (T = Double) fractionalAll -> ritorna T tc T e' somma di parteFrazionaria
   di ogni elemento di Vettore


PolinomioAstratto<T>

Polinomio sottotipo di Calcolabile

contiene metodi astratti propri di ogni polinomio

contiene metodi:

Operazioni Algebriche

-> operator+(virtuale,puro,parametrico) -> ritorna polinomio somma di 2 polinomi passati
-> operator-(virtuale,puro,parametrico) -> ritorna polinomio differenza di 2 polinomi passati
-> operator* (virtuale,puro,parametrico) -> ritorna polinomio prodotto di 2 polinomi passati

-> operator* monomio (virtuale,puro,parametrico) -> ritorna polinomio dato da Polinomio e Monomio passato
-> operator/ (virtuale,puro,parametrico) -> ritorna polinomio divisione di 2 polinomi passati

Operazioni Booleani

-> operator== (virtuale,puro,parametrico) -> ritorna true sse oggetti sono
   uguali per ogni elemento che li compone ,false altrimenti
-> operator!=  (virtuale,puro,parametrico) -> negazione di uguaglianza

-> operator<  (virtuale,puro,parametrico) -> ritorna true sse primo polinomio < secondo , false altrimenti
-> operator<= (virtuale,puro,parametrico) -> ritorna true sse primo polinomio <= secondo , false altrimenti

-> operator> (virtuale,puro,parametrico) -> ritorna true sse primo polinomio > secondo , false altrimenti
-> operator>= (virtuale,puro,parametrico) -> ritorna true sse primo polinomio >= secondo , false altrimenti


Operazioni Ulteriori

-> first (virtuale) -> ritorna primo elemento di polinomio
-> rest(virtuale) -> ritorna resto degli elemento di polinomio

-> getElementNumber (virtuale)-> ritorna il numero di elementi di polinomio
-> maxDegree(virtuale) -> ritorna il grado massimo del polinomio

-> derivative -> ritorna derivata prima di polinomio

PolinomioConcreto<T>

T = Razionale,Intero

PolinomioConcreto sottotipo di PolinomioAstratto

implementazione concreta e templatizzata di metodi supertipo

implementazione metodo aggiuntivo (T = intero) powerAll
implementazione metodo aggiuntivo (T = razionale) reduceAll


Operazioni Algebriche

-> operator+(virtuale,puro,parametrico) -> ritorna polinomio somma di 2 polinomi passati
-> operator-(virtuale,puro,parametrico) -> ritorna polinomio differenza di 2 polinomi passati
-> operator* (virtuale,puro,parametrico) -> ritorna polinomio prodotto di 2 polinomi passati

-> operator* monomio (virtuale,puro,parametrico) -> ritorna polinomio dato da Polinomio e Monomio passato
-> operator/ (virtuale,puro,parametrico) -> ritorna polinomio divisione di 2 polinomi passati

Operazioni Booleani

-> operator== (virtuale,puro,parametrico) -> ritorna true sse oggetti sono
   uguali per ogni elemento che li compone ,false altrimenti
-> operator!=  (virtuale,puro,parametrico) -> negazione di uguaglianza

-> operator<  (virtuale,puro,parametrico) -> ritorna true sse primo polinomio < secondo , false altrimenti
-> operator<= (virtuale,puro,parametrico) -> ritorna true sse primo polinomio <= secondo , false altrimenti

-> operator> (virtuale,puro,parametrico) -> ritorna true sse primo polinomio > secondo , false altrimenti
-> operator>= (virtuale,puro,parametrico) -> ritorna true sse primo polinomio >= secondo , false altrimenti


Operazioni Ulteriori

-> first (virtuale) -> ritorna primo elemento di polinomio
-> rest(virtuale) -> ritorna resto degli elemento di polinomio

-> getElementNumber (virtuale)-> ritorna il numero di elementi di polinomio
-> maxDegree (virtuale) -> ritorna il grado massimo del polinomio
-> isEmpty(virtuale,puro,parametrico,statico) -> true sse elemento
   passato e' nullo
-> addConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di somma, false altrimenti
-> subConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di sottrazione,false altrimenti
-> mulConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di prodotto,false altrimenti
-> divConsistent(virtuale,puro,parametrico,statico) -> true sse
   elementi passati sono consistenti con operazione di divisione,false altrimenti

Operazioni Proprie

-> (T = Razionale) reduceAll -> riduce ai minimi termini ogni elementoVettore
-> (T = Intero) powerAll -> ritorna T tc T e' somma di Potenza di ogni elemento appartenente a vettore


BLACK BOX ARCH


Calcolabile

addConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A is null -> F
B is null -> F
(A > 0 , B > 0), A + B > LIMITE_SUP -> F
(A < 0 , B < 0), A + B < LIMITE_INF -> F
T ALTRIMENTI

dim A > 1,B > 1 :
impossibile

subConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
(A > 0 , B > 0), A - B < LIMITE_INF -> F
(A < 0 , B > 0), A - B < LIMITE_INF -> F
(A > 0 , B < 0), A - B < LIMITE_SUP -> F
T ALTRIMENTI

dim A > 1,B > 1 :
impossibile

mulConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
(A > 0 , B > 0), A * B > LIMITE_SUP -> F  
(A < 0 , B < 0), A * B > LIMITE_SUP -> F
(A > 0 , B < 0), A * B < LIMITE_INF -> F
(A < 0 , B > 0), A * B < LIMITE_INF -> F
T ALTRIMENTI


dim A > 1,B > 1 :
impossibile 

//DIPENDE DA TIPO (consistenza divisione tra razionali diversa da altri)!
divConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
B = 0 -> F
(A > 0 , B > 0), A / B > LIMITE_SUP -> F  
(A < 0 , B < 0), A / B > LIMITE_SUP -> F
(A > 0 , B < 0), A / B < LIMITE_INF -> F
(A < 0 , B > 0), A / B < LIMITE_INF -> F
T ALTRIMENTI


dim A > 1,B > 1 :
impossibile


VettoreConcreto<T>

VettoreConcreto<T>::Calcolabile::Operazioni Ulteriori

metodi :

-> isEmpty(virtuale,puro,parametrico,statico) 
-> addConsistent(virtuale,puro,parametrico,statico)
-> subConsistent(virtuale,puro,parametrico,statico) 
-> mulConsistent(virtuale,puro,parametrico,statico) 
-> divConsistent(virtuale,puro,parametrico,statico) 

isEmpty(virtuale,puro,parametrico,statico)

Sia A input

dim A= 0 :
impossibile

dim A = 1 :
A is null -> eccezione
A is !null -> n |
  n e' il numero di elementi del vettore


dim A > 1 :
impossibile

addConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A is null -> F
B is null -> F

(A > 0 , B > 0), A + B  > LIMITE_SUP -> F
(A < 0 , B < 0), A + B  < LIMITE_INF -> F
       
T ALTRIMENTI

dim A > 1,B > 1 :
impossibile

subConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A is null -> F
B is null -> F
(A > 0 , B > 0), A - B < LIMITE_INF -> F
(A < 0 , B > 0), A - B < LIMITE_INF -> F
(A > 0 , B < 0), A - B < LIMITE_SUP -> F

T ALTRIMENTI

dim A > 1,B > 1 :
impossibile

mulConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A is null -> F
B is null -> F

(A > 0 , B > 0), A * B > LIMITE_SUP -> F
(A < 0 , B < 0), A * B > LIMITE_SUP -> F
(A > 0 , B < 0), A * B < LIMITE_INF -> F
(A < 0 , B > 0), A * B < LIMITE_INF -> F

T ALTRIMENTI


dim A > 1,B > 1 :
impossibile 

//DIPENDE DA TIPO (consistenza divisione tra razionali diversa da altri)!
divConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
B = 0 -> F

(A > 0 , B > 0), A / B > LIMITE_SUP -> F  
(A < 0 , B < 0), A / B > LIMITE_SUP -> F
(A > 0 , B < 0), A / B < LIMITE_INF -> F
(A < 0 , B > 0), A / B < LIMITE_INF -> F

T ALTRIMENTI


dim A > 1,B > 1 :
impossibile


VettoreConcreto<T>::Operazioni Algebriche


metodi

-> operator+(virtuale,puro,parametrico) 
-> operator-(virtuale,puro,parametrico) 
-> operator* (virtuale,puro,parametrico)
-> operator* monomio (virtuale,puro,parametrico)
-> operator/ (virtuale,puro,parametrico)


operator+ (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    addConsistent = F -> eccezione
    addConsistent = T -> somma |
    		  somma e' somma di A e B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile
    

operator- (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    subConsistent = F -> eccezione
    subConsistent = T -> differenza |
    		  differenza e' differenza tra A e B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile
    

operator* (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    mulConsistent = F -> eccezione
    mulConsistent = T -> prodotto |
    		  prodotto e' prodotto tra A e B
    
dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator* scalare (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    mulConsistent = F -> eccezione
    mulConsistent = T -> prodotto |
    		  prodotto e' prodotto tra A e B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile



operator/ scalare (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    divConsistent = F -> eccezione
    divConsistent = T -> quoziente |
    		  quoziente e' divisione tra A e B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


VettoreConcreto<T>::Operazioni Booleane

Sia A,B input

metodi:
-> operator==(virtuale,puro,parametrico)
-> operator!=(virtuale,puro,parametrico) 
-> operator<  (virtuale,puro,parametrico) 
-> operator<= (virtuale,puro,parametrico) 
-> operator> (virtuale,puro,parametrico) 
-> operator>= (virtuale,puro,parametrico)


operator== (virtuale,puro,parametrico) 

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A == B -> T 
    !(A == B) -> F

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator!= (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A != B -> T
    !(A != B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator<  (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A < B -> T
    !(A < B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator<= (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A <= B -> T
    !(A <= B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator> (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, dimB = 1:

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB 
    A > B -> T
    !(A > B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator>= (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A >= B -> T
    !(A >= B) -> F

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile

VettoreConcreto<T>::Operazioni Ulteriori

Sia A input

metodi:
-> getRowNumber (virtuale)

getRowNumber(virtuale)

dim A = 0:
    impossibile

dim A = 1:
    A isEmpty -> 0
    !(A is Empty) -> n |
    	n e' numero elementi di Vettore

dim A > 1:
    -> impossibile

VettoreConcreto<T>::Operazioni Proprie

sia A input

metodi:
-> (T = Razionale) reduceAll
-> (T = Intero) powerAll 
-> (T = Double) fractionalAll

reduceAll(virtuale)

dim A = 0:
    impossibile

dim A = 1:
    A isEmpty -> eccezione
    !(A isEmpty) -> A' |
    A' <-> A ridotto ai minimo per ogni suo elemento

dim A > 2:
    impossibile:

powerAll(virtuale)

dim A = 0:
    impossibile

dim A = 1:
    A isEmpty -> 0
    !(A isEmpty) -> potenza |
    	potenza e' somma di ogni elemento di A elevato al quadrato,
	potenza < LIMITE_SUP
	se potenza >= LIMITE_SUP -> eccezione

dim A > 2:
    impossibile


fractionalAll(virtuale)

dim A = 0 :
    impossibile

dim A = 1:
    A isEmpty -> 0
    !(A isEmpty) -> fractional |
    	fractional e' somma di parte frazionaria di ogni
	elemento di A,
	fractional e' < LIMITE_SUP
	se fractional >= LIMITE_SUP -> eccezione // improbabile

dim A > 1 :
    impossibile


FINE OPERAZIONI VETTORE CONCRETO

////////////////////////////////
////////////////////////////////
////////////////////////////////



MatriceConcreta<T>



MatriceConcreta<T>

MatriceConcreta<T>::Calcolabile::Operazioni Ulteriori

metodi :

-> isEmpty(virtuale,puro,parametrico,statico) 
-> addConsistent(virtuale,puro,parametrico,statico)
-> subConsistent(virtuale,puro,parametrico,statico) 
-> mulConsistent(virtuale,puro,parametrico,statico) 
-> divConsistent(virtuale,puro,parametrico,statico) 

isEmpty(virtuale,puro,parametrico,statico)

Sia A input

dim A = 0 :
impossibile

dim A = 1 :
A <-> null -> T
A <-> a -> F

dim A > 1 :
impossibile

addConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
(A > 0 , B > 0), A + B > LIMITE_SUP -> F
(A < 0 , B < 0), A + B < LIMITE_INF -> F
T ALTRIMENTI

dim A > 1,B > 1 :
impossibile

subConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
(A > 0 , B > 0), A - B < LIMITE_INF -> F
(A < 0 , B > 0), A - B < LIMITE_INF -> F
(A > 0 , B < 0), A - B < LIMITE_SUP -> F
T ALTRIMENTI

dim A > 1,B > 1 :
impossibile

mulConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
(A > 0 , B > 0), A * B > LIMITE_SUP -> F  
(A < 0 , B < 0), A * B > LIMITE_SUP -> F
(A > 0 , B < 0), A * B < LIMITE_INF -> F
(A < 0 , B > 0), A * B < LIMITE_INF -> F
T ALTRIMENTI


dim A > 1,B > 1 :
impossibile 

//DIPENDE DA TIPO (consistenza divisione tra razionali diversa da altri)!
divConsistent(virtuale,puro,parametrico,statico)

sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
impossibile

dim A = 1,B = 1:
A <-> null -> F
B <-> null -> F
B = 0 -> F
(A > 0 , B > 0), A / B > LIMITE_SUP -> F  
(A < 0 , B < 0), A / B > LIMITE_SUP -> F
(A > 0 , B < 0), A / B < LIMITE_INF -> F
(A < 0 , B > 0), A / B < LIMITE_INF -> F
T ALTRIMENTI


dim A > 1,B > 1 :
impossibile


MatriceConcreta<T>::Operazioni Algebriche


metodi

-> operator+(virtuale,puro,parametrico) 
-> operator-(virtuale,puro,parametrico) 
-> operator* (virtuale,puro,parametrico)
-> operator* monomio (virtuale,puro,parametrico)
-> operator/ (virtuale,puro,parametrico)


operator+ (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    addConsistent = F -> eccezione
    addConsistent = T -> somma A,B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile
    

operator- (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    subConsistent = F -> eccezione
    subConsistent = T -> differenza A,B 

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile
    

operator* (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    mulConsistent = F -> eccezione
    mulConsistent = T -> prodotto A,B
    
dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator* scalare (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    mulConsistent = F -> eccezione
    mulConsistent = T -> prodotto A,B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile



operator/ scalare (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, B = 1: 
    A isEmpty = T, B isEmpty = T -> eccezione
    dim A = 1, B isEmpty = T -> eccezione
    A isEmpty = T , B = 1 -> eccezione
    divConsistent = F -> eccezione
    divConsistent = T -> divisione A,B

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


MatriceConcreta<T>::Operazioni Booleane

Sia A,B input

metodi:
-> operator==(virtuale,puro,parametrico)
-> operator!=(virtuale,puro,parametrico) 
-> operator<  (virtuale,puro,parametrico) 
-> operator<= (virtuale,puro,parametrico) 
-> operator> (virtuale,puro,parametrico) 
-> operator>= (virtuale,puro,parametrico)


operator== (virtuale,puro,parametrico) 

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A == B -> T 
    !(A == B) -> F

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator!= (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A != B -> T
    !(A != B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator<  (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A < B -> T
    !(A < B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator<= (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A <= B -> T
    !(A <= B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator> (virtuale,puro,parametrico) 

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A = 1, dimB = 1:

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB 
    A > B -> T
    !(A > B) -> F


dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


operator>= (virtuale,puro,parametrico)

Sia A,B input

dim A = 0 , B = 0 
dim A = 1 , B = 0
dim A = 0 , B = 1:
    impossibile

dim A isEmpty = T, B isEmpty = T:
    eccezione
dim A = 1, B isEmpty = T:
    eccezione
dim A isEmpty = T , B = 1:
    eccezione

dim A = 1, dimB = 1:
    A >= B -> T
    !(A >= B) -> F

dim A > 1, B qualsiasi:
    impossibile
dim A qualsiasi , B > 1:
    impossibile


MatriceConcreta<T>::Operazioni Ulteriori


metodi:
-> transpose  (virtuale,puro) 
-> getRowNumber (virtuale) 
-> getColumnNumber (virtuale)
-> getElementNumber(virtuale)
-> isSquare 
-> isIdentity 
-> isUpperTriangular 
-> isLowerTriangular


transpose

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> 0
    A !(isEmpty), !(null) -> A' |
      A' e' trasposta di A

dim A > 1 :
    impossibile


getRowNumber(virtuale)

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> 0
    A !(isEmpty), !(null) -> n |
      n e' numero righe di A

dim A > 1 :
    impossibile


getColumnNumber:

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> 0
    A !(isEmpty), !(null) -> n |
      n e' numero colonne di A

dim A > 1 :
    impossibile


getElementNumber:

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> 0
    A !(isEmpty), !(null) -> n |
      n e' numero colonne * numero di righe di A

dim A > 1 :
    impossibile


isSquare:

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> F
    A !(isEmpty), !(null), A getRowNumber == A getColumnNumber -> T,
    F altrimenti 

dim A > 1 :
    impossibile


isIdentity:

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> F
    A !(isEmpty), !(null),
      (A isUpperTriangular), (A isLowerTriangular),
      (ogni elemento su diagonale = 1) -> T,
    F altrimenti
      

dim A > 1 :
    impossibile


isUpperTriangular:

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> F
    A !(isEmpty), !(null),
    A isSquare, ogni elemento sotto diagonale principale = 0 -> T
    F altrimenti

dim A > 1 :
    impossibile

isLowerTriangular:

Sia A input

dim A = 0 :
    impossibile

dim A = 1:
    A is null -> eccezione
    A isEmpty -> F
    A !(isEmpty), !(null),
    A isSquare, ogni elemento sopra diagonale principale = 0 -> T,
    F altrimenti
